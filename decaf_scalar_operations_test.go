package ed448

import . "gopkg.in/check.v1"

func (s *Ed448Suite) Test_ScalarAdditionAndSubtraction(c *C) {

	scalar1 := [scalarWords]word_t{
		50, 0, 0, 0, 6, 0, 0, 3, 0, 0, 0, 2, 1, 1,
	}

	scalar2 := [scalarWords]word_t{
		5, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1,
	}

	subExp := [scalarWords]word_t{
		45, 0, 0, 0, 6, 0, 0, 1, 0, 0, 0, 2, 1, 0,
	}

	addExp := [scalarWords]word_t{
		55, 0, 0, 0, 6, 0, 0, 5, 0, 0, 0, 2, 1, 2,
	}

	added := scalarAdd(scalar1, scalar2)
	subtracted := scalarSub(scalar1, scalar2)

	c.Assert(added, DeepEquals, addExp)
	c.Assert(subtracted, DeepEquals, subExp)
}

func (s *Ed448Suite) Test_ScalarHalve(c *C) {

	scalar1 := [scalarWords]word_t{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
	}

	scalar2 := [scalarWords]word_t{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
	}

	exp := [scalarWords]word_t{
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
	}

	halved := svHalve(scalar1, scalar2)

	c.Assert(halved, DeepEquals, exp)
}

func (s *Ed448Suite) Test_GenerateConstant(c *C) {

	c.Skip("in progress")

	constant := [scalarWords]word_t{
		0x4a7bb0cf, 0xc873d6d5, 0x23a70aad, 0xe933d8d7, 0x129c96fd, 0xbb124b65, 0x335dc163,
		0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
	}

	scalar := scalarAdjustment()

	c.Assert(constant, DeepEquals, scalar)
}

func (s *Ed448Suite) Test_AddNielsToProjective(c *C) {
	na := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	nb := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	nc := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	n := &twNiels{
		na,
		nb,
		nc,
	}

	ex := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	ey := &bigNumber{0x00000001, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	ez := &bigNumber{0x00000001, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	et := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	e := &pointT{
		ex, ey, ez, et,
	}

	expx := &bigNumber{0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0ffffffe, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
	}

	expy := &bigNumber{0x0d1ab6e7, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
	}

	expz := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
	}

	expt := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}
	exp := &pointT{
		expx, expy, expz, expt,
	}

	e.addNielsToProjective(n)

	c.Assert(e.x, DeepEquals, exp.x)
	c.Assert(e.y, DeepEquals, exp.y)
	c.Assert(e.z, DeepEquals, exp.z)
	c.Assert(e.t, DeepEquals, exp.t)
}

func (s *Ed448Suite) Test_ConvertNielsToProjective(c *C) {
	na := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	nb := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	nc := &bigNumber{0x068d5b74, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	n := &twNiels{
		na,
		nb,
		nc,
	}

	ex := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	ey := &bigNumber{0x00000001, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	ez := &bigNumber{0x00000001, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	et := &bigNumber{0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	e := &pointT{
		ex, ey, ez, et,
	}

	expx := &bigNumber{0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0ffffffe, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
	}

	expy := &bigNumber{0x0d1ab6e8, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	expz := &bigNumber{0x00000001, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
		0x00000000, 0x00000000,
	}

	expt := &bigNumber{0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0ffffffe, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
		0x0fffffff, 0x0fffffff,
	}

	exp := &pointT{
		expx, expy, expz, expt,
	}

	convertNielsToPt(e, n)

	c.Assert(e.x, DeepEquals, exp.x)
	c.Assert(e.y, DeepEquals, exp.y)
	c.Assert(e.z, DeepEquals, exp.z)
	c.Assert(e.t, DeepEquals, exp.t)
}
